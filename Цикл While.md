# Цикл While у python
У своєму житті ми часто стикаємося з ситуаціями, коли доводиться повторювати одні і ті ж дії, але не вказану кількість разів, а "доки треба"...

Уявімо ситуацію, що нам потрібно начистити відро картоплі. Ми не знаємо скільки у відрі картоплин, а отже неправильним буде наступний алгоритм:
```
For k in range(20):
	візьми картоплину
	почисть
	поклади у чисту каструлю
```

З одного боку, картоплин виявиться більше і тоді ми почистимо тільки 20 з них, а з іншого боку картоплин може бути менше і тоді ми будемо шкребти по дну відра намагаючись взяти неіснуючу картоплину.

Ще один приклад у якому нам не допоможе цикл з лічильником, ситуація з переходом дороги на зелене світло. Якщо світлофор облаштований циферблатом то цикл де ми будемо повторювати команду "стій" є класичним прикладом циклу з лічильником. **Але що робити, якщо ми не знаємо коли увімкнеться зелене світло?**

В цьому випадку ми стоїмо, стоїмо стоїмо, а фактично повторюємо команду тій доти, доки істинним є висловлювання "колір світлофору червоний".

Тобто і у випадку з відром картоплі і у випадку світлофору, перед тим як почати повторення дій, ми перевіряємо істинність деякого висловлювання (виразу). Якщо відповідь True - команди в тілі циклу виконуються один раз і знову відбувається перевірка умови.

## Цикл з передумовою. WHILE
Для того, щоб побудувати алгоритмічну конструкцію, у якій команди повторюються лише у випадку істинності умови називається **цикл з передумовою** і має наступний вигляд:
```python
While <логічний вираз>:
	команда1
	команда2
```

Розглянемо задачу у якій Вам потрібно знайти суму чисел які вводяться з клавіатури. Першим питанням у цій задачі є кількість чисел які ми збираємося додавати. Але цього разу, ми не знаємо відповіді скільки їх буде. Ми накладемо умову, що додавати числа потрібно до тих пір, доки число, що вводиться з клавіатури є невід'ємним, тобто 0 та більші.

Отже, нехай змінна, яка буде зберігати введене нами число буде k, а команда, що буде отримувати числа k = int(input()), змінна, що накопичуватиме у собі суму введених чисел **s** і тоді код матиме наступний вигляд:
```python

s = 0
k = int(input())
s = s + k

```
Вже на наступному кроці нам знову треба ввести число і знову його додати до s, але тепер ми можемо побудувати циклічну конструкцію яка буде повторювати дві останні команди доки значення, що було введено у k не буде менше 0.
```python

S = 0
k = int(input())
S = S + k
while k >= 0:
	k = int(input())
	S = S + k	

print(S)
```
Отже у даному прикладі, після запуску ми повинні ввести число, яке у третьому рядку буде додано до **S** і якщо **k** задовольняє умову while відбудеться виконання команд із тіла циклу.

Якщо запустити цей код - він буде працювати, адже перед циклом ми вже маємо число k, яке перевіряє цикл (умова циклу залежить від значення k), але що буде, якщо першого разу ввести від'ємне число? У цьому випадку **умова буде хибною і тіло циклу не виконається жодного разу**. А на додачу ми отримаємо на екрані суму, що буде від'ємним числом.

З іншого боку, якщо ми введемо числа 1, 2, 3, -1, то наш алгоритм спрацює наступним чином.

- Число 1 буде додано до S(1) перед циклом.
- Число 2 буде введено командою з циклу, адже умова k(1)>=0 є істинною і 2 буде додано до S(3). 
- Число 3 буде додано на другій ітерації і теж буде додано до S(6).
- Число -1 буде додано на третій ітерації і ТЕЖ БУДЕ ДОДАНО ДО S(5)
- Значення змінної S буде виведено на екран.

Але як бачимо такий алгоритм призведе до того, що у випадку введення якогось великого від'ємного числа - результат додавання буде неправильним! Як бути?

У цьому випадку можна піти кількома шляхами.
  
### Додаємо перевірку введеного значення k
```python
S = 0
k = int(input())
if k>-1:
    S = S + k
while k >= 0:
    k = int(input())
    if k>-1:
	    S = S + k	

print(S)
```
У цьому прикладі ми перед тим, як додавати число до суми ми перевіряємо чи є воно невід'ємним. Але, як уже розглядалося у попередніх уроках, у циклах порядок інколи...

### Порядок має значення

Коли ми вперше ввели число ми можемо його не додавати відразу до S, а перейти до циклу. Якщо число у k є невід'ємним то цикл почне свою роботу, але тепер, розуміючи, що у нас уже є число у k, ми спочатку його додамо до S, а потім знову попросимо ввести число k.
```python
S = 0
k = int(input())
while k >= 0:
    S = S + k
    k = int(input())

print(S)
```

Тепер, наш код буде видавати той самий результат, але при цьому матиме менше команд, а ми, після того як нам набридне вводити числа, що додаються до суми змушені будемо ввести якесь від'ємне число. Але оскільки відразу після цього відбувається перевірка умови (команда введення остання в тілі циклу), цикл зупинить роботу і не буде додавати від'ємне число до S.   
Залишилося лише виконати останню команду і отримати на екрані суму невід'ємних чисел невідомої кількості.

### Завдання. А якщо ми захочемо порахувати скільки ввели чисел?
У цьому випадку нам потрібно ввести у текст програми змінну **а** якій на початку програми присвоїти 0, а у тілі циклу треба збільшувати її значення на 1.

Змініть код, так, щоб програма вивела на екран приблизно настуний текст:

Всього було введено 10 чисел  
Сума введених чисел 28

